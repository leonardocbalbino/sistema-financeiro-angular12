import { getterForProp } from './column-prop-getters';
export function optionalGetterForProp(prop) {
    return prop && (row => getterForProp(prop)(row, prop));
}
/**
 * This functions rearrange items by their parents
 * Also sets the level value to each of the items
 *
 * Note: Expecting each item has a property called parentId
 * Note: This algorithm will fail if a list has two or more items with same ID
 * NOTE: This algorithm will fail if there is a deadlock of relationship
 *
 * For example,
 *
 * Input
 *
 * id -> parent
 * 1  -> 0
 * 2  -> 0
 * 3  -> 1
 * 4  -> 1
 * 5  -> 2
 * 7  -> 8
 * 6  -> 3
 *
 *
 * Output
 * id -> level
 * 1      -> 0
 * --3    -> 1
 * ----6  -> 2
 * --4    -> 1
 * 2      -> 0
 * --5    -> 1
 * 7     -> 8
 *
 *
 * @param rows
 *
 */
export function groupRowsByParents(rows, from, to) {
    if (from && to) {
        const nodeById = {};
        const l = rows.length;
        let node = null;
        nodeById[0] = new TreeNode(); // that's the root node
        const uniqIDs = rows.reduce((arr, item) => {
            const toValue = to(item);
            if (arr.indexOf(toValue) === -1) {
                arr.push(toValue);
            }
            return arr;
        }, []);
        for (let i = 0; i < l; i++) {
            // make TreeNode objects for each item
            nodeById[to(rows[i])] = new TreeNode(rows[i]);
        }
        for (let i = 0; i < l; i++) {
            // link all TreeNode objects
            node = nodeById[to(rows[i])];
            let parent = 0;
            const fromValue = from(node.row);
            if (!!fromValue && uniqIDs.indexOf(fromValue) > -1) {
                parent = fromValue;
            }
            node.parent = nodeById[parent];
            node.row['level'] = node.parent.row['level'] + 1;
            node.parent.children.push(node);
        }
        let resolvedRows = [];
        nodeById[0].flatten(function () {
            resolvedRows = [...resolvedRows, this.row];
        }, true);
        return resolvedRows;
    }
    else {
        return rows;
    }
}
class TreeNode {
    constructor(row = null) {
        if (!row) {
            row = {
                level: -1,
                treeStatus: 'expanded'
            };
        }
        this.row = row;
        this.parent = null;
        this.children = [];
    }
    flatten(f, recursive) {
        if (this.row['treeStatus'] === 'expanded') {
            for (let i = 0, l = this.children.length; i < l; i++) {
                const child = this.children[i];
                f.apply(child, Array.prototype.slice.call(arguments, 2));
                if (recursive)
                    child.flatten.apply(child, arguments);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bzd2ltbGFuZS9uZ3gtZGF0YXRhYmxlLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBSXRELE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxJQUFxQjtJQUN6RCxPQUFPLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3pELENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQ0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsSUFBVyxFQUFFLElBQTBCLEVBQUUsRUFBd0I7SUFDbEcsSUFBSSxJQUFJLElBQUksRUFBRSxFQUFFO1FBQ2QsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdEIsSUFBSSxJQUFJLEdBQW9CLElBQUksQ0FBQztRQUVqQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQyxDQUFDLHVCQUF1QjtRQUVyRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ3hDLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN6QixJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQy9CLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDbkI7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsc0NBQXNDO1lBQ3RDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMvQztRQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsNEJBQTRCO1lBQzVCLElBQUksR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0IsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2YsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxJQUFJLENBQUMsQ0FBQyxTQUFTLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtnQkFDbEQsTUFBTSxHQUFHLFNBQVMsQ0FBQzthQUNwQjtZQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQztRQUVELElBQUksWUFBWSxHQUFVLEVBQUUsQ0FBQztRQUM3QixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQ2xCLFlBQVksR0FBRyxDQUFDLEdBQUcsWUFBWSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM3QyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFVCxPQUFPLFlBQVksQ0FBQztLQUNyQjtTQUFNO1FBQ0wsT0FBTyxJQUFJLENBQUM7S0FDYjtBQUNILENBQUM7QUFFRCxNQUFNLFFBQVE7SUFLWixZQUFZLE1BQWtCLElBQUk7UUFDaEMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLEdBQUcsR0FBRztnQkFDSixLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUNULFVBQVUsRUFBRSxVQUFVO2FBQ3ZCLENBQUM7U0FDSDtRQUNELElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVELE9BQU8sQ0FBQyxDQUFNLEVBQUUsU0FBa0I7UUFDaEMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUN6QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDcEQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN6RCxJQUFJLFNBQVM7b0JBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQ3REO1NBQ0Y7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXR0ZXJGb3JQcm9wIH0gZnJvbSAnLi9jb2x1bW4tcHJvcC1nZXR0ZXJzJztcbmltcG9ydCB7IFRhYmxlQ29sdW1uUHJvcCB9IGZyb20gJy4uL3R5cGVzL3RhYmxlLWNvbHVtbi50eXBlJztcblxuZXhwb3J0IHR5cGUgT3B0aW9uYWxWYWx1ZUdldHRlciA9IChyb3c6IGFueSkgPT4gYW55IHwgdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsR2V0dGVyRm9yUHJvcChwcm9wOiBUYWJsZUNvbHVtblByb3ApOiBPcHRpb25hbFZhbHVlR2V0dGVyIHtcbiAgcmV0dXJuIHByb3AgJiYgKHJvdyA9PiBnZXR0ZXJGb3JQcm9wKHByb3ApKHJvdywgcHJvcCkpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb25zIHJlYXJyYW5nZSBpdGVtcyBieSB0aGVpciBwYXJlbnRzXG4gKiBBbHNvIHNldHMgdGhlIGxldmVsIHZhbHVlIHRvIGVhY2ggb2YgdGhlIGl0ZW1zXG4gKlxuICogTm90ZTogRXhwZWN0aW5nIGVhY2ggaXRlbSBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgcGFyZW50SWRcbiAqIE5vdGU6IFRoaXMgYWxnb3JpdGhtIHdpbGwgZmFpbCBpZiBhIGxpc3QgaGFzIHR3byBvciBtb3JlIGl0ZW1zIHdpdGggc2FtZSBJRFxuICogTk9URTogVGhpcyBhbGdvcml0aG0gd2lsbCBmYWlsIGlmIHRoZXJlIGlzIGEgZGVhZGxvY2sgb2YgcmVsYXRpb25zaGlwXG4gKlxuICogRm9yIGV4YW1wbGUsXG4gKlxuICogSW5wdXRcbiAqXG4gKiBpZCAtPiBwYXJlbnRcbiAqIDEgIC0+IDBcbiAqIDIgIC0+IDBcbiAqIDMgIC0+IDFcbiAqIDQgIC0+IDFcbiAqIDUgIC0+IDJcbiAqIDcgIC0+IDhcbiAqIDYgIC0+IDNcbiAqXG4gKlxuICogT3V0cHV0XG4gKiBpZCAtPiBsZXZlbFxuICogMSAgICAgIC0+IDBcbiAqIC0tMyAgICAtPiAxXG4gKiAtLS0tNiAgLT4gMlxuICogLS00ICAgIC0+IDFcbiAqIDIgICAgICAtPiAwXG4gKiAtLTUgICAgLT4gMVxuICogNyAgICAgLT4gOFxuICpcbiAqXG4gKiBAcGFyYW0gcm93c1xuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwUm93c0J5UGFyZW50cyhyb3dzOiBhbnlbXSwgZnJvbT86IE9wdGlvbmFsVmFsdWVHZXR0ZXIsIHRvPzogT3B0aW9uYWxWYWx1ZUdldHRlcik6IGFueVtdIHtcbiAgaWYgKGZyb20gJiYgdG8pIHtcbiAgICBjb25zdCBub2RlQnlJZCA9IHt9O1xuICAgIGNvbnN0IGwgPSByb3dzLmxlbmd0aDtcbiAgICBsZXQgbm9kZTogVHJlZU5vZGUgfCBudWxsID0gbnVsbDtcblxuICAgIG5vZGVCeUlkWzBdID0gbmV3IFRyZWVOb2RlKCk7IC8vIHRoYXQncyB0aGUgcm9vdCBub2RlXG5cbiAgICBjb25zdCB1bmlxSURzID0gcm93cy5yZWR1Y2UoKGFyciwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgdG9WYWx1ZSA9IHRvKGl0ZW0pO1xuICAgICAgaWYgKGFyci5pbmRleE9mKHRvVmFsdWUpID09PSAtMSkge1xuICAgICAgICBhcnIucHVzaCh0b1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSwgW10pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIC8vIG1ha2UgVHJlZU5vZGUgb2JqZWN0cyBmb3IgZWFjaCBpdGVtXG4gICAgICBub2RlQnlJZFt0byhyb3dzW2ldKV0gPSBuZXcgVHJlZU5vZGUocm93c1tpXSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIC8vIGxpbmsgYWxsIFRyZWVOb2RlIG9iamVjdHNcbiAgICAgIG5vZGUgPSBub2RlQnlJZFt0byhyb3dzW2ldKV07XG4gICAgICBsZXQgcGFyZW50ID0gMDtcbiAgICAgIGNvbnN0IGZyb21WYWx1ZSA9IGZyb20obm9kZS5yb3cpO1xuICAgICAgaWYgKCEhZnJvbVZhbHVlICYmIHVuaXFJRHMuaW5kZXhPZihmcm9tVmFsdWUpID4gLTEpIHtcbiAgICAgICAgcGFyZW50ID0gZnJvbVZhbHVlO1xuICAgICAgfVxuICAgICAgbm9kZS5wYXJlbnQgPSBub2RlQnlJZFtwYXJlbnRdO1xuICAgICAgbm9kZS5yb3dbJ2xldmVsJ10gPSBub2RlLnBhcmVudC5yb3dbJ2xldmVsJ10gKyAxO1xuICAgICAgbm9kZS5wYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZWRSb3dzOiBhbnlbXSA9IFtdO1xuICAgIG5vZGVCeUlkWzBdLmZsYXR0ZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZWRSb3dzID0gWy4uLnJlc29sdmVkUm93cywgdGhpcy5yb3ddO1xuICAgIH0sIHRydWUpO1xuXG4gICAgcmV0dXJuIHJlc29sdmVkUm93cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm93cztcbiAgfVxufVxuXG5jbGFzcyBUcmVlTm9kZSB7XG4gIHB1YmxpYyByb3c6IGFueTtcbiAgcHVibGljIHBhcmVudDogYW55O1xuICBwdWJsaWMgY2hpbGRyZW46IGFueVtdO1xuXG4gIGNvbnN0cnVjdG9yKHJvdzogYW55IHwgbnVsbCA9IG51bGwpIHtcbiAgICBpZiAoIXJvdykge1xuICAgICAgcm93ID0ge1xuICAgICAgICBsZXZlbDogLTEsXG4gICAgICAgIHRyZWVTdGF0dXM6ICdleHBhbmRlZCdcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMucm93ID0gcm93O1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gIH1cblxuICBmbGF0dGVuKGY6IGFueSwgcmVjdXJzaXZlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMucm93Wyd0cmVlU3RhdHVzJ10gPT09ICdleHBhbmRlZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBmLmFwcGx5KGNoaWxkLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkgY2hpbGQuZmxhdHRlbi5hcHBseShjaGlsZCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==