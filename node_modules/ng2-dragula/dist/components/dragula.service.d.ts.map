{"version":3,"file":"dragula.service.d.ts","sources":["dragula.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Group } from '../Group';\nimport { DragulaOptions } from '../DragulaOptions';\nimport { Observable } from 'rxjs';\nimport { DrakeFactory } from '../DrakeFactory';\nexport declare class DragulaService {\n    private drakeFactory;\n    private dispatch$;\n    drag: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        source: Element;\n    }>;\n    dragend: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n    }>;\n    drop: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        target: Element;\n        source: Element;\n        sibling: Element;\n    }>;\n    private elContainerSource;\n    cancel: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        container: Element;\n        source: Element;\n    }>;\n    remove: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        container: Element;\n        source: Element;\n    }>;\n    shadow: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        container: Element;\n        source: Element;\n    }>;\n    over: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        container: Element;\n        source: Element;\n    }>;\n    out: (groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        container: Element;\n        source: Element;\n    }>;\n    cloned: (groupName?: string) => Observable<{\n        name: string;\n        clone: Element;\n        original: Element;\n        cloneType: \"mirror\" | \"copy\";\n    }>;\n    dropModel: <T = any>(groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        target: Element;\n        source: Element;\n        sibling: Element;\n        item: T;\n        sourceModel: T[];\n        targetModel: T[];\n        sourceIndex: number;\n        targetIndex: number;\n    }>;\n    removeModel: <T = any>(groupName?: string) => Observable<{\n        name: string;\n        el: Element;\n        container: Element;\n        source: Element;\n        item: T;\n        sourceModel: T[];\n        sourceIndex: number;\n    }>;\n    private groups;\n    constructor(drakeFactory?: DrakeFactory);\n    /** Public mainly for testing purposes. Prefer `createGroup()`. */\n    add(group: Group): Group;\n    find(name: string): Group;\n    destroy(name: string): void;\n    /**\n     * Creates a group with the specified name and options.\n     *\n     * Note: formerly known as `setOptions`\n     */\n    createGroup<T = any>(name: string, options: DragulaOptions<T>): Group;\n    private handleModels({name, drake, options});\n    private setupEvents(group);\n    private domIndexOf(child, parent);\n}\n"]}